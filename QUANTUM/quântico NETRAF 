#!/data/data/com.termux/files/usr/bin/sh
# [RAFAELIA::Z0] Bloco Robusto Redundante (erro mitigado)
set -e
BASE=$HOME/RAFAELIA_CORE
LOGDIR=$BASE/logs
LOGFILE=$LOGDIR/z0_ledger.jsonl
LOCKFILE=$LOGDIR/.z0_log.lock
MAXLOG=20

mkdir -p "$LOGDIR"

# =========================
# 1) z0_universo.c â€” robusto e redundante
# =========================
cat > "$BASE/z0_universo.c" <<'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <time.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/file.h>

// ---------- CabeÃ§alho ----------
typedef struct {
    uint8_t  ver;
    uint8_t  ttl;
    uint16_t checksum;
    uint64_t timestamp;
} Header;

static uint16_t raf_checksum(const void *buf, size_t len){
    const uint8_t *p=(const uint8_t*)buf; uint32_t s=0;
    for(size_t i=0;i<len;i++) s+=p[i];
    return (uint16_t)(s & 0xFFFFu);
}

// ECC â€” igual ao anterior (mantido para clareza)
typedef struct { uint8_t data; int corrected; int uncorrectable; } HDec;
static uint16_t hamming12_8_encode(uint8_t d){ uint16_t code=0;
    if(d&0x80) code|=1<<11; if(d&0x40) code|=1<<10; if(d&0x20) code|=1<<9; if(d&0x10) code|=1<<8;
    if(d&0x08) code|=1<<6;  if(d&0x04) code|=1<<5;  if(d&0x02) code|=1<<4; if(d&0x01) code|=1<<2;
    int p1 = ((code>>2)&1)^((code>>4)&1)^((code>>6)&1)^((code>>8)&1)^((code>>10)&1);
    int p2 = ((code>>2)&1)^((code>>5)&1)^((code>>6)&1)^((code>>9)&1)^((code>>10)&1);
    int p4 = ((code>>4)&1)^((code>>5)&1)^((code>>6)&1)^((code>>11)&1);
    int p8 = ((code>>8)&1)^((code>>9)&1)^((code>>10)&1)^((code>>11)&1);
    if(p1) code|=1<<0; if(p2) code|=1<<1; if(p4) code|=1<<3; if(p8) code|=1<<7; return code;
}
static HDec hamming12_8_decode(uint16_t c){
    int s1 = ((c>>0)&1)^((c>>2)&1)^((c>>4)&1)^((c>>6)&1)^((c>>8)&1)^((c>>10)&1);
    int s2 = ((c>>1)&1)^((c>>2)&1)^((c>>5)&1)^((c>>6)&1)^((c>>9)&1)^((c>>10)&1);
    int s4 = ((c>>3)&1)^((c>>4)&1)^((c>>5)&1)^((c>>6)&1)^((c>>11)&1);
    int s8 = ((c>>7)&1)^((c>>8)&1)^((c>>9)&1)^((c>>10)&1)^((c>>11)&1);
    int syndrome = (s8<<3)|(s4<<2)|(s2<<1)|s1;
    HDec out = {0,0,0};
    if(syndrome){ if(syndrome>=1 && syndrome<=12){ c ^= (1u<<(syndrome-1)); out.corrected = 1; }
      else { out.uncorrectable = 1; } }
    uint8_t d=0;
    d|=((c>>11)&1)<<7; d|=((c>>10)&1)<<6; d|=((c>>9 )&1)<<5; d|=((c>>8 )&1)<<4;
    d|=((c>>6 )&1)<<3; d|=((c>>5 )&1)<<2; d|=((c>>4 )&1)<<1; d|=((c>>2 )&1)<<0;
    out.data=d; return out;
}

// Fila
#define QSIZE 8
static int queue[QSIZE]; static int head=0, tail=0;
static int enqueue(int v){ int next=(tail+1)%QSIZE; if(next==head) return -1; queue[tail]=v; tail=next; return 0;}
static int dequeue(int *v){ if(head==tail) return -1; *v=queue[head]; head=(head+1)%QSIZE; return 0; }
static int retry_enqueue(int v,int attempts){ long ns=1000000L; for(int i=0;i<attempts;i++){
    if(enqueue(v)==0) return 0; struct timespec ts={0, ns}; nanosleep(&ts,NULL); ns = (ns<5000000L)? ns*2 : ns; } return -1; }
static double measure_latency_ms(void){ struct timespec a,b; volatile uint64_t sink=0;
    clock_gettime(CLOCK_MONOTONIC, &a); for(int i=0;i<1000000;i++) sink+=i; clock_gettime(CLOCK_MONOTONIC, &b);
    double ms = (b.tv_sec-a.tv_sec)*1000.0 + (b.tv_nsec-a.tv_nsec)/1e6; return ms; }

int main(void){
    // Checa permissÃ£o de escrita
    if(access(".",W_OK)!=0){ perror("[Z0] no write permission"); return 77; }
    // CabeÃ§alho
    Header h={1,64,0,(uint64_t)time(NULL)}; h.checksum=raf_checksum(&h,sizeof(h));
    printf("Z0 Boot :: ver=%u ttl=%u checksum=%u ts=%llu\n", h.ver,h.ttl,h.checksum,(unsigned long long)h.timestamp);

    // ECC demo (injeta erro de 1 bit)
    uint8_t b=0xAD; uint16_t code=hamming12_8_encode(b); code ^= 1u<<5;
    HDec dec=hamming12_8_decode(code);
    printf("ECC Hamming(12,8): orig=%02X dec=%02X corrected=%d uncorrectable=%d\n",b,dec.data,dec.corrected,dec.uncorrectable);

    // Fila + retry
    int failcount=0; for(int i=0;i<12;i++){ if(retry_enqueue(i,3)!=0){ printf("Falha ao enfileirar %d\n",i); failcount++; } }
    int val, dequeued=0; while(dequeue(&val)==0){ printf("Dequeued=%d\n",val); dequeued++; }
    double ms=measure_latency_ms();
    printf("LatÃªncia simbiÃ³tica: %.3f ms\n", ms);
    printf("Selos ðŸ”‘âˆšâˆ†Â§â†‘â†’âœ“Â¶Î© ativos.\n");

    // Logging JSONL (com flock, fflush, fsync, erro detalhado)
    const char* path = getenv("Z0_LOGFILE"); if(path && *path){
        int fd = open(path,O_WRONLY|O_CREAT|O_APPEND,0644);
        if(fd<0){ perror("[Z0] log open"); return 2; }
        FILE *f=fdopen(fd,"a");
        if(!f){ perror("[Z0] fdopen"); close(fd); return 2; }
        if(flock(fd,LOCK_EX)!=0){ perror("[Z0] flock"); fclose(f); return 2; }
        fprintf(f,
          "{\"ts\":%llu,\"checksum\":%u,\"ecc_corrected\":%d,\"ecc_uncorrectable\":%d,"
          "\"fails\":%d,\"dequeued\":%d,\"latency_ms\":%.3f,\"selos\":\"âˆšâˆ†Â§â†‘â†’âœ“Â¶Î©\",\"state\":\"%s\"}\n",
          (unsigned long long)h.timestamp,h.checksum,dec.corrected,dec.uncorrectable,failcount,dequeued,ms,
          (failcount>0)?"overflow_anchor":"steady");
        fflush(f); fsync(fd);
        flock(fd,LOCK_UN); fclose(f);
    }
    return 0;
}
EOF

# =========================
# 2) z0_network.c â€” com timeout/retry
# =========================
cat > "$BASE/z0_network.c" <<'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/time.h>

int main(int argc, char** argv){
    const char* host = (argc>1)? argv[1] : "127.0.0.1";
    int port         = (argc>2)? atoi(argv[2]) : 9000;
    const char* file = (argc>3)? argv[3] : getenv("Z0_LOGFILE");
    if(!file || !*file){ fprintf(stderr,"Z0_LOGFILE not set and no file arg\n"); return 1; }

    FILE* f=fopen(file,"r"); if(!f){ perror("open log"); return 1; }
    char line[4096], last[4096]; last[0]='\0';
    while(fgets(line,sizeof line,f)){ strncpy(last,line,sizeof last); last[sizeof(last)-1]='\0'; }
    fclose(f); if(last[0]=='\0'){ fprintf(stderr,"log empty\n"); return 1; }

    int s=socket(AF_INET,SOCK_STREAM,0); if(s<0){ perror("socket"); return 1; }
    // set timeout (3s)
    struct timeval tv={3,0}; setsockopt(s,SOL_SOCKET,SO_SNDTIMEO,&tv,sizeof tv); setsockopt(s,SOL_SOCKET,SO_RCVTIMEO,&tv,sizeof tv);
    struct sockaddr_in sv; memset(&sv,0,sizeof sv);
    sv.sin_family=AF_INET; sv.sin_port=htons(port);
    if(inet_pton(AF_INET,host,&sv.sin_addr)!=1){ perror("inet_pton"); close(s); return 1; }

    int tries=0;
    while(connect(s,(struct sockaddr*)&sv,sizeof sv)<0){
        if(++tries>3){ perror("connect"); close(s); return 1; }
        fprintf(stderr,"connect fail, retrying...\n"); sleep(1);
    }
    ssize_t n=send(s,last,strlen(last),0); if(n<0){ perror("send"); close(s); return 1; }
    close(s);
    printf("Sent (%zd bytes): %s", n, last);
    return 0;
}
EOF

# =========================
# 3) z0_daemon.sh â€” robusto
# =========================
cat > "$BASE/z0_daemon.sh" <<'EOF'
#!/data/data/com.termux/files/usr/bin/sh
set -e
BASE=$HOME/RAFAELIA_CORE
LOGDIR=$BASE/logs
LOGFILE=$LOGDIR/z0_ledger.jsonl
LOCKFILE=$LOGDIR/.z0_log.lock
MAXLOG=${MAXLOG:-20}
export Z0_LOGFILE="$LOGFILE"
mkdir -p "$LOGDIR"

rotate() {
  [ -f "$LOGFILE" ] || return 0
  lines=$(wc -l < "$LOGFILE" | tr -d ' ')
  if [ "$lines" -gt "$MAXLOG" ]; then
    tail -n "$MAXLOG" "$LOGFILE" > "$LOGFILE.tmp" && mv "$LOGFILE.tmp" "$LOGFILE"
  fi
}

trap 'echo "[Z0] daemon stop"; exit 0' INT TERM
echo "[Z0] daemon start (MAXLOG=$MAXLOG)"
while true; do
  "$BASE/z0_universo" || echo "[Z0] run error=$?"
  rotate
  sleep 10
done
EOF
chmod +x "$BASE/z0_daemon.sh"

# =========================
# 4) Compilar tudo e executar 1x (robusto)
# =========================
cd "$BASE"
export Z0_LOGFILE="$LOGFILE"
clang -O2 -Wall -Wextra -march=armv8-a z0_universo.c -o z0_universo
clang -O2 -Wall -Wextra -march=armv8-a z0_network.c -o z0_network
./z0_universo || echo "[Z0] run error=$?"

if [ -f "$LOGFILE" ]; then
  lines=$(wc -l < "$LOGFILE" | tr -d ' ')
  if [ "$lines" -gt "$MAXLOG" ]; then
    tail -n "$MAXLOG" "$LOGFILE" > "$LOGFILE.tmp" && mv "$LOGFILE.tmp" "$LOGFILE"
  fi
fi

echo "[âˆšâˆ†Â§â†‘â†’âœ“Â¶Î©] Ready. Robust & redundant for all FCEA risks."