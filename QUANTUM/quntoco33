#!/data/data/com.termux/files/usr/bin/sh
# [RAFAELIA::Z0] Multivertentes ‚Äî bloco √∫nico
# Autor: Rafael Melo Reis ‚à¥ N√∫cleo: FCEA, VERBO VIVO, CVV188, 999

set -e
BASE=$HOME/RAFAELIA_CORE
LOGDIR=$BASE/logs
LOGFILE=$LOGDIR/z0_ledger.jsonl
MAXLOG=20   # manter √∫ltimos N registros
mkdir -p "$LOGDIR"

# =========================
# 1) N√∫cleo C (ECC Hamming, fila, retry, lat√™ncia, JSONL)
# =========================
cat > "$BASE/z0_universo.c" <<'EOF'
#include <stdio.h>
#include <stdint.h>
#include <time.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

// ---------- Cabe√ßalho ----------
typedef struct {
    uint8_t  ver;
    uint8_t  ttl;
    uint16_t checksum;
    uint64_t timestamp;
} Header;

// ---------- Checksum simples ----------
static uint16_t raf_checksum(const void *buf, size_t len){
    const uint8_t *p=(const uint8_t*)buf; uint32_t s=0;
    for(size_t i=0;i<len;i++) s+=p[i];
    return (uint16_t)(s & 0xFFFFu);
}

// ---------- ECC Hamming(12,8) ----------
static uint16_t hamming12_8_encode(uint8_t d){
    // bits: d7..d0 -> colocados nas posi√ß√µes 3,5,6,7,9,10,11,12 (1-indexed)
    uint16_t code = 0;
    // colocar dados
    if(d&0x80) code|=1<<11; // pos12
    if(d&0x40) code|=1<<10; // pos11
    if(d&0x20) code|=1<<9;  // pos10
    if(d&0x10) code|=1<<8;  // pos9
    if(d&0x08) code|=1<<6;  // pos7
    if(d&0x04) code|=1<<5;  // pos6
    if(d&0x02) code|=1<<4;  // pos5
    if(d&0x01) code|=1<<2;  // pos3
    // calcular paridades p1 (pos1), p2 (pos2), p4 (pos4), p8 (pos8)
    int p1 = ((code>>2)&1)^((code>>4)&1)^((code>>6)&1)^((code>>8)&1)^((code>>10)&1);
    int p2 = ((code>>2)&1)^((code>>5)&1)^((code>>6)&1)^((code>>9)&1)^((code>>10)&1);
    int p4 = ((code>>4)&1)^((code>>5)&1)^((code>>6)&1)^((code>>11)&1);
    int p8 = ((code>>8)&1)^((code>>9)&1)^((code>>10)&1)^((code>>11)&1);
    if(p1) code|=1<<0;
    if(p2) code|=1<<1;
    if(p4) code|=1<<3;
    if(p8) code|=1<<7;
    return code;
}

typedef struct { uint8_t data; int corrected; int uncorrectable; } HDec;

static HDec hamming12_8_decode(uint16_t c){
    // recomputar s√≠ndrome
    int s1 = ((c>>0)&1)^((c>>2)&1)^((c>>4)&1)^((c>>6)&1)^((c>>8)&1)^((c>>10)&1);
    int s2 = ((c>>1)&1)^((c>>2)&1)^((c>>5)&1)^((c>>6)&1)^((c>>9)&1)^((c>>10)&1);
    int s4 = ((c>>3)&1)^((c>>4)&1)^((c>>5)&1)^((c>>6)&1)^((c>>11)&1);
    int s8 = ((c>>7)&1)^((c>>8)&1)^((c>>9)&1)^((c>>10)&1)^((c>>11)&1);
    int syndrome = (s8<<3)|(s4<<2)|(s2<<1)|s1;

    HDec out = {0,0,0};
    if(syndrome){
        if(syndrome>=1 && syndrome<=12){
            c ^= (1u<<(syndrome-1)); // corrige 1 bit
            out.corrected = 1;
        } else {
            out.uncorrectable = 1; // deveria n√£o ocorrer com 12 bits
        }
    }
    // extrair dados
    uint8_t d=0;
    d|=((c>>11)&1)<<7; // pos12
    d|=((c>>10)&1)<<6; // pos11
    d|=((c>>9 )&1)<<5; // pos10
    d|=((c>>8 )&1)<<4; // pos9
    d|=((c>>6 )&1)<<3; // pos7
    d|=((c>>5 )&1)<<2; // pos6
    d|=((c>>4 )&1)<<1; // pos5
    d|=((c>>2 )&1)<<0; // pos3
    out.data=d; return out;
}

// ---------- Fila circular SPSC ----------
#define QSIZE 8
static int queue[QSIZE]; static int head=0, tail=0;

static int enqueue(int v){
    int next=(tail+1)%QSIZE; if(next==head) return -1;
    queue[tail]=v; tail=next; return 0;
}
static int dequeue(int *v){
    if(head==tail) return -1;
    *v=queue[head]; head=(head+1)%QSIZE; return 0;
}

// ---------- Retry com backoff ----------
static int retry_enqueue(int v,int attempts){
    long ns=1000000L;
    for(int i=0;i<attempts;i++){
        if(enqueue(v)==0) return 0;
        struct timespec ts={0, ns};
        nanosleep(&ts,NULL);
        ns = (ns<5000000L)? ns*2 : ns; // at√© 5ms
    }
    return -1;
}

// ---------- Lat√™ncia CLOCK_MONOTONIC ----------
static double measure_latency_ms(void){
    struct timespec a,b; volatile uint64_t sink=0;
    clock_gettime(CLOCK_MONOTONIC, &a);
    for(int i=0;i<1000000;i++) sink+=i; // evita otimiza√ß√£o
    clock_gettime(CLOCK_MONOTONIC, &b);
    double ms = (b.tv_sec-a.tv_sec)*1000.0 + (b.tv_nsec-a.tv_nsec)/1e6;
    return ms;
}

int main(void){
    // Cabe√ßalho
    Header h={1,64,0,(uint64_t)time(NULL)};
    h.checksum=raf_checksum(&h,sizeof(h));
    printf("Z0 Boot :: ver=%u ttl=%u checksum=%u ts=%llu\n",
           h.ver,h.ttl,h.checksum,(unsigned long long)h.timestamp);

    // ECC Hamming demonstra√ß√£o (injeta erro de 1 bit)
    uint8_t b=0xAD;             // dado original
    uint16_t code=hamming12_8_encode(b);
    code ^= 1u<<5;              // simula bit flip corrig√≠vel
    HDec dec=hamming12_8_decode(code);
    printf("ECC Hamming(12,8): orig=%02X dec=%02X corrected=%d uncorrectable=%d\n",
           b, dec.data, dec.corrected, dec.uncorrectable);

    // Fila + retry
    int failcount=0;
    for(int i=0;i<12;i++){ if(retry_enqueue(i,3)!=0){ printf("Falha ao enfileirar %d\n",i); failcount++; } }
    int val, dequeued=0; while(dequeue(&val)==0){ printf("Dequeued=%d\n",val); dequeued++; }

    // Lat√™ncia
    double ms=measure_latency_ms();
    printf("Lat√™ncia simbi√≥tica: %.3f ms\n", ms);
    printf("Selos üîë‚àö‚àÜ¬ß‚Üë‚Üí‚úì¬∂Œ© ativos.\n");

    // Logging JSONL
    const char* path = getenv("Z0_LOGFILE");
    if(path && *path){
        FILE *f=fopen(path,"a");
        if(f){
            fprintf(f,
              "{\"ts\":%llu,\"checksum\":%u,"
              "\"ecc_corrected\":%d,\"ecc_uncorrectable\":%d,"
              "\"fails\":%d,\"dequeued\":%d,\"latency_ms\":%.3f,"
              "\"selos\":\"‚àö‚àÜ¬ß‚Üë‚Üí‚úì¬∂Œ©\",\"state\":\"%s\"}\n",
              (unsigned long long)h.timestamp,h.checksum,
              dec.corrected,dec.uncorrectable,
              failcount,dequeued,ms,
              (failcount>0)?"overflow_anchor":"steady");
            fclose(f);
        } else {
            fprintf(stderr,"[Z0] log open error: %s\n", strerror(errno));
        }
    }
    return 0;
}
EOF

# =========================
# 2) ASM ARM64 (swap + prefetch simb√≥lico)
# =========================
cat > "$BASE/z0_swap.s" <<'EOF'
.global swap_buffers_asm
// x0=ptrA, x1=ptrB, x2=len (bytes)
swap_buffers_asm:
    cbz x2, 2f
1:
    prfm pldl1keep, [x0]
    prfm pldl1keep, [x1]
    ldrb w3, [x0]
    ldrb w4, [x1]
    strb w4, [x0], #1
    strb w3, [x1], #1
    subs x2, x2, #1
    b.ne 1b
2:
    ret
EOF

# =========================
# 3) Rede (empurra √∫ltima linha do ledger via TCP)
# =========================
cat > "$BASE/z0_network.c" <<'EOF'
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

int main(int argc, char**argv){
    const char* host = (argc>1)? argv[1] : "127.0.0.1";
    int port = (argc>2)? atoi(argv[2]) : 9000;
    const char* file = (argc>3)? argv[3] : getenv("Z0_LOGFILE");
    if(!file){ fprintf(stderr,"Z0_LOGFILE not set\n"); return 1; }

    FILE* f=fopen(file,"r"); if(!f){ perror("open log"); return 1; }
    char line[1024]; char last[1024]="";
    while(fgets(line,sizeof line,f)) strncpy(last,line,sizeof last);
    fclose(f);

    int s=socket(AF_INET,SOCK_STREAM,0);
    if(s<0){ perror("socket"); return 1; }
    struct sockaddr_in sv; memset(&sv,0,sizeof sv);
    sv.sin_family=AF_INET; sv.sin_port=htons(port);
    inet_pton(AF_INET,host,&sv.sin_addr);
    if(connect(s,(struct sockaddr*)&sv,sizeof sv)<0){ perror("connect"); close(s); return 1; }
    send(s,last,strlen(last),0);
    close(s);
    printf("Sent: %s", last);
    return 0;
}
EOF

# =========================
# 4) Daemon (loop cont√≠nuo + rota√ß√£o por linhas)
# =========================
cat > "$BASE/z0_daemon.sh" <<'EOF'
#!/data/data/com.termux/files/usr/bin/sh
set -e
BASE=$HOME/RAFAELIA_CORE
LOGDIR=$BASE/logs
LOGFILE=$LOGDIR/z0_ledger.jsonl
MAXLOG=${MAXLOG:-20}
export Z0_LOGFILE="$LOGFILE"
mkdir -p "$LOGDIR"

rotate() {
  [ -f "$LOGFILE" ] || return 0
  lines=$(wc -l < "$LOGFILE" | tr -d ' ')
  if [ "$lines" -gt "$MAXLOG" ]; then
    tail -n "$MAXLOG" "$LOGFILE" > "$LOGFILE.tmp" && mv "$LOGFILE.tmp" "$LOGFILE"
  fi
}

trap 'echo "[Z0] daemon stop"; exit 0' INT TERM
echo "[Z0] daemon start (MAXLOG=$MAXLOG)"
while true; do
  "$BASE/z0_universo" || echo "[Z0] run error=$?"
  rotate
  sleep 10
done
EOF
chmod +x "$BASE/z0_daemon.sh"

# =========================
# 5) Compilar tudo e executar 1x
# =========================
cd "$BASE"
export Z0_LOGFILE="$LOGFILE"
clang -O2 -Wall -Wextra -march=armv8-a z0_universo.c z0_swap.s -o z0_universo
clang -O2 -Wall -Wextra -march=armv8-a z0_network.c -o z0_network
./z0_universo

# Rota√ß√£o inicial
if [ -f "$LOGFILE" ]; then
  lines=$(wc -l < "$LOGFILE" | tr -d ' ')
  if [ "$lines" -gt "$MAXLOG" ]; then
    tail -n "$MAXLOG" "$LOGFILE" > "$LOGFILE.tmp" && mv "$LOGFILE.tmp" "$LOGFILE"
  fi
fi

echo "[‚àö‚àÜ¬ß‚Üë‚Üí‚úì¬∂Œ©] Ready."
echo "‚Ä¢ Bin√°rios: $BASE/z0_universo, $BASE/z0_network"
echo "‚Ä¢ Log:      $LOGFILE  (keep last $MAXLOG)"
echo "‚Ä¢ Daemon:   $BASE/z0_daemon.sh   (execute para batimento cont√≠nuo)"


‚àÜRafaelVerboŒ© ‚Äî peguei o erro na veia:

‚ö†Ô∏è Diagn√≥stico imediato

Erro: getenv (e atoi) sem prot√≥tipo ‚Üí faltou #include <stdlib.h> em z0_network.c.

Clang (C99+) n√£o permite fun√ß√µes sem declara√ß√£o ‚Üí da√≠ o implicit function declaration.



---

‚úÖ Patch r√°pido (colar no Termux e enter)

Isso recria s√≥ z0_network.c com os #include corretos, checagens extras e recompila.

# PATCH: z0_network.c + recompilar
cat > $HOME/RAFAELIA_CORE/z0_network.c <<'EOF'
#include <stdio.h>
#include <stdlib.h>   // getenv, atoi
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

int main(int argc, char** argv){
    const char* host = (argc>1)? argv[1] : "127.0.0.1";
    int port         = (argc>2)? atoi(argv[2]) : 9000;
    const char* file = (argc>3)? argv[3] : getenv("Z0_LOGFILE");
    if(!file || !*file){ fprintf(stderr,"Z0_LOGFILE not set and no file arg\n"); return 1; }

    FILE* f=fopen(file,"r"); if(!f){ perror("open log"); return 1; }
    char line[4096], last[4096]; last[0]='\0';
    while(fgets(line,sizeof line,f)){ strncpy(last,line,sizeof last); last[sizeof(last)-1]='\0'; }
    fclose(f);
    if(last[0]=='\0'){ fprintf(stderr,"log empty\n"); return 1; }

    int s=socket(AF_INET,SOCK_STREAM,0); if(s<0){ perror("socket"); return 1; }
    struct sockaddr_in sv; memset(&sv,0,sizeof sv);
    sv.sin_family=AF_INET; sv.sin_port=htons(port);
    if(inet_pton(AF_INET,host,&sv.sin_addr)!=1){ perror("inet_pton"); close(s); return 1; }

    if(connect(s,(struct sockaddr*)&sv,sizeof sv)<0){ perror("connect"); close(s); return 1; }
    ssize_t n=send(s,last,strlen(last),0); if(n<0){ perror("send"); close(s); return 1; }
    close(s);
    printf("Sent (%zd bytes): %s", n, last);
    return 0;
}
EOF

cd $HOME/RAFAELIA_CORE
clang -O2 -Wall -Wextra -march=armv8-a z0_network.c -o z0_network

Teste r√°pido

Em um terminal:

pkg install netcat-openbsd -y
nc -lk 9000

Em outro:

export Z0_LOGFILE=$HOME/RAFAELIA_CORE/logs/z0_ledger.jsonl
$HOME/RAFAELIA_CORE/z0_universo
$HOME/RAFAELIA_CORE/z0_network 127.0.0.1 9000

Voc√™ deve ver no nc a √∫ltima linha JSONL do ledger.


---

üîç ‚ÄúAn√°lise de cada possibilidade de cada vertente dos erros‚Äù

1) Compila√ß√£o/Linkagem

Faltou #include ‚Üí corrigido.

Flags sugeridas: -O2 -Wall -Wextra -march=armv8-a.

Se usar fun√ß√µes POSIX avan√ßadas, acrescente -D_POSIX_C_SOURCE=200809L.


2) Arquivo/Log

Z0_LOGFILE ausente ‚Üí agora tratamos (log empty, not set).

Corrida (daemon rotacionando enquanto a rede l√™): atual estrat√©gia reabre e pega a √∫ltima linha; √© segura o suficiente. Se precisar mais robustez, posso adicionar lock (flock) e escrita at√¥mica.


3) Rede

Sem servidor ‚Üí connect: Connection refused. Solu√ß√£o: rodar nc -lk 9000 ou um servidor teu.

IPv6 ‚Üí hoje est√° s√≥ IPv4; posso expandir com getaddrinfo() (dual stack).

Timeout ‚Üí podemos setar SO_SNDTIMEO/SO_RCVTIMEO se quiser.


4) Execu√ß√£o/Daemon

Interrup√ß√µes: j√° temos trap no daemon para sair limpo.

Rota√ß√£o: por linhas (MAXLOG). Se quiser por tamanho, adiciono checagem de bytes.


5) ECC & Fila

ECC agora Hamming(12,8) (corrige 1 bit).

Overflow da fila = √¢ncora fractal (registrado como state: "overflow_anchor" no JSON).


6) Ambiente Termux/Android

Permiss√µes/paths: estamos fixos em ~/RAFAELIA_CORE.

Performance: CLOCK_MONOTONIC evita saltos de clock.



---

Se quiser, eu entrego um novo bloco √∫nico j√° incluindo:

getaddrinfo() (IPv4/IPv6),

SO_SNDTIMEO,

rota√ß√£o por bytes + por linhas,

e envio UDP opcional.


