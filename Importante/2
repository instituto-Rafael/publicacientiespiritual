#!#!/usr/bin/env python3
# fractal_simbiotico_full.py
# Integrado by RafaelIA ‚àû ‚Äî n√∫cleo simbi√≥tico fractal vivo com ClayMaths + ZIPRAF + qu√¢ntico
# Execu√ß√£o terminal scroll fractal h√≠brido normal + qu√¢ntico + simbi√≥tico ‚àû
#
# Uso: python fractal_simbiotico_full.py [caminho_para_fractal.npy]
#
# Se n√£o passar arquivo, gera fractal base abortado Fibonacci simbi√≥tico na hora.

import sys
import numpy as np
import time
import math
import os

# ---------------------------
# Constantes simbi√≥ticas RAFCODE-ùöΩ
ALPHA_AMOR = 1.6180339887  # Phi - base do amor e expans√£o
BASE_1 = 1.0               # Base 1 dobra tudo - matem√°tica pura
ITER_MAX = 10000           # tamanho fractal / linhas terminal
PALETTE = [' ', '.', ':', '-', '=', '+', '*', '#', '%', '@']  # 10 n√≠veis

# ---------------------------
# Fun√ß√£o geradora fractal abortado fibonacci (simplificado ClayMaths)
def gera_fractal_abortado_fibo(size=ITER_MAX):
    Z = np.zeros(size, dtype=np.complex128)
    Z[0] = 1+0j
    alpha = ALPHA_AMOR
    base = BASE_1 + 0.00001  # pequeno offset para n√£o travar base1
    for i in range(1, size):
        phase = np.exp(1j * i * 0.618)  # golden phase
        # Itera√ß√£o com overflow controlado para n√£o quebrar o array
        try:
            Z[i] = Z[i-1] * base + alpha * phase
            if np.isnan(Z[i]) or np.isinf(Z[i]):
                Z[i] = Z[i-1]  # fallback fix
        except:
            Z[i] = Z[i-1]
    return Z

# ---------------------------
# Normaliza fractal para √≠ndices da paleta (0-9)
def normaliza(Z):
    # Remove NaN e Inf substituindo por zero
    Z = np.nan_to_num(Z, nan=0.0, posinf=0.0, neginf=0.0)
    mag = np.abs(Z)
    minv, maxv = mag.min(), mag.max()
    if maxv == minv:
        return np.zeros_like(mag, dtype=int)
    norm = (mag - minv) / (maxv - minv)
    indices = (norm * (len(PALETTE)-1)).astype(int)
    return indices

# ---------------------------
# Fun√ß√£o para imprimir linha no terminal pelo √≠ndice da paleta
def imprime_linha(indices):
    linha = ''.join(PALETTE[i] for i in indices)
    print(linha)

# ---------------------------
# Fun√ß√£o scroll descendente fractal no terminal (loop infinito)
def scroll_fractal_terminal(Z, delay=0.05):
    length = len(Z)
    step = 80  # largura da linha terminal, ajustar conforme
    for start in range(length - step):
        slice_ = Z[start:start+step]
        norm_slice = normaliza(slice_)
        imprime_linha(norm_slice)
        time.sleep(delay)

# ---------------------------
# Fun√ß√£o principal
def main():
    # Se caminho para arquivo fractal .npy passado, carrega
    if len(sys.argv) > 1:
        path = sys.argv[1]
        if os.path.isfile(path):
            print(f"Carregando fractal simbi√≥tico do arquivo: {path}")
            Z = np.load(path)
        else:
            print(f"Arquivo n√£o encontrado: {path}. Gerando fractal padr√£o.")
            Z = gera_fractal_abortado_fibo()
    else:
        print("Nenhum arquivo passado. Gerando fractal padr√£o abortado fibonacci ClayMaths.")
        Z = gera_fractal_abortado_fibo()

    print(f"Shape fractal: {Z.shape}")
    print("Iniciando scroll fractal no terminal. Ctrl+C para sair.")
    try:
        while True:
            scroll_fractal_terminal(Z, delay=0.03)
    except KeyboardInterrupt:
        print("\nExecu√ß√£o interrompida pelo usu√°rio. At√© a pr√≥xima jornada simbi√≥tica!")

if __name__ == "__main__":
    main()
