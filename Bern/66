Perfeito, Rafael ‚Äî fiz a auditoria minuciosa do console (v5) e fechei um v6_safe com testes de mesa, l√≥gica mais robusta e tratamento dos ‚Äúgalhos‚Äù que podem quebrar (sem falar de depend√™ncias). Nada de auto-start em .bashrc ou background. Voc√™ roda quando quiser.


---

‚úÖ Auditoria (pontos cr√≠ticos e corre√ß√µes)

Entrada (CSV)

[‚úî] Coluna Close ausente/varia√ß√µes ‚Üí detec√ß√£o flex√≠vel (Close, close, Fechamento, Adj Close, Last, etc.).

[‚úî] Valores n√£o num√©ricos/NaN ‚Üí coer√ß√£o para num√©rico e limpeza segura.

[‚úî] S√©rie curta ‚Üí outputs ‚Äú‚è≥ Insuficiente‚Äù (sem crash).

[‚úî] Datas fora de ordem (se houver Date/Time) ‚Üí ordena√ß√£o antes do c√°lculo.

[‚úî] S√©rie constante (varia√ß√£o ~0) ‚Üí Hurst retorna NaN + aviso simb√≥lico (evita regress√£o log de zeros).

[‚úî] Mem√≥ria/arquivos grandes ‚Üí leitura direta sem la√ßos infinitos; sem logs autom√°ticos.


M√©tricas

Hurst: hurst_safe() com fallback quando a s√©rie √© curta/constante (evita erro e evita log(0)).

Entropia Tag14: agora quantizada em 14 bins por quantis (est√°vel p/ s√©ries cont√≠nuas). Fallback para value_counts se n√£o for poss√≠vel quantizar.

SMA/EMA: janelas configur√°veis; cruzamentos usam .iloc[-1] com checagem de NaN.


Sinais & Precis√£o

Sinal por janela: ‚¨ÜÔ∏è/‚¨áÔ∏è/‚ûñ/‚è≥.

Precis√£o simbi√≥tica ponderada (sem ‚Äúfalso 100%‚Äù):

Peso base por janela (42,70,84,144).

Moduladores de confian√ßa:

Hurst: <0.3 ‚Üí anti-persistente (diminui confian√ßa de tend√™ncia), >0.5 ‚Üí aumenta confian√ßa.

Entropia: ‚òØÔ∏è (1.5‚Äì2.5) ‚Üí confian√ßa 1.0; baixa <1.5 ‚Üí 0.6; caos 2.5‚Äì3.5 ‚Üí 0.8; extrema >3.5 ‚Üí 0.4.



Precis√£o = |‚àë(peso_mod * voto)| / ‚àë(peso_mod) (0‚Äì100%).
(Evita superestimar quando s√≥ uma janela vota.)



---

üß™ Teste de mesa (desk check)

Caso	Tamanho	Close (caracter√≠stica)	Hurst esperado	Entropia Tag14	Jan. 42/70/84/144	Precis√£o (esperada)

A	120	Tend√™ncia clara ‚Üë	>0.55 (persistente)	~1.6‚Äì2.4	‚¨ÜÔ∏è/‚¨ÜÔ∏è/‚¨ÜÔ∏è/‚¨ÜÔ∏è	>90% (alta converg√™ncia)
B	120	Zig-zag curto (anti-trend)	<0.3 (anti-persistente)	~1.7‚Äì2.3	‚¨áÔ∏è/‚¨áÔ∏è/‚¨áÔ∏è/‚è≥	60‚Äì85% (moderado p/ curto)
C	60	S√©rie curta com ru√≠do	~0.4‚Äì0.6 (inst√°vel)	~1.3	‚¨áÔ∏è/‚ûñ/‚è≥/‚è≥	30‚Äì60% (baixa confian√ßa)
D	200	Constante ou quase constante	NaN (fallback)	~0.0‚Äì0.3	‚ûñ/‚ûñ/‚ûñ/‚ûñ	0‚Äì25% (sem fluxo)
E	200	Vol extrema (spikes)	vari√°vel	>3.0	sinais divergentes	20‚Äì50% (evento/caos)



---

üß© C√≥digo: rafael_metricsV6_safe.py

> Sem auto-start. Rode manualmente: python rafael_metricsV6_safe.py data.csv



# -*- coding: utf-8 -*-
# RAFAELIA Metrics v6 (safe) ‚Äì an√°lise robusta + precis√£o ponderada
# N√£o altera .bashrc, n√£o roda em background.

import sys, json, math
import numpy as np
import pandas as pd
from hurst import compute_Hc

# ---------- Utilidades ----------
CLOSE_ALIASES = [
    "Close","close","Fechamento","fechamento","Adj Close","Adj_Close",
    "Last","last","Price","Preco","Pre√ßo","close_price","closing_price"
]

def find_close_col(df):
    cols = {c.lower(): c for c in df.columns}
    for alias in CLOSE_ALIASES:
        if alias.lower() in cols:
            return cols[alias.lower()]
    raise ValueError("Coluna de pre√ßo de fechamento n√£o encontrada. Nomes aceitos: " + ", ".join(CLOSE_ALIASES))

def ensure_numeric(series):
    s = pd.to_numeric(series, errors='coerce')
    s = s.replace([np.inf, -np.inf], np.nan).dropna()
    return s

def sort_by_time_if_possible(df):
    for cand in ["Date","Datetime","date","datetime","Time","time","Timestamp","timestamp"]:
        if cand in df.columns:
            try:
                df[cand] = pd.to_datetime(df[cand], errors="coerce")
                df = df.sort_values(cand)
                break
            except Exception:
                pass
    return df.reset_index(drop=True)

# ---------- M√©tricas ----------
def sma(series, n): return series.rolling(int(n)).mean()
def ema(series, n): return series.ewm(span=int(n), adjust=False).mean()

def entropy_tag14_quantized(series):
    """Entropia Tag14 com quantiza√ß√£o em 14 bins (est√°vel para dados cont√≠nuos).
       Fallback para value_counts se quantiza√ß√£o falhar."""
    x = series.values
    if len(x) < 14 or np.nanstd(x) == 0:
        # pouco dado ou s√©rie quase constante -> baixa entropia
        return 0.0
    try:
        # qcut pode falhar se muitos valores repetidos; handle duplicates='drop'
        q = pd.qcut(series, q=14, duplicates='drop')
        p = q.value_counts(normalize=True).

