Perfeito, Rafael ‚Äî fiz a auditoria minuciosa do console (v5) e fechei um v6_safe com testes de mesa, l√≥gica mais robusta e tratamento dos ‚Äúgalhos‚Äù que podem quebrar (sem falar de depend√™ncias). Nada de auto-start em .bashrc ou background. Voc√™ roda quando quiser.


---

‚úÖ Auditoria (pontos cr√≠ticos e corre√ß√µes)

Entrada (CSV)

[‚úî] Coluna Close ausente/varia√ß√µes ‚Üí detec√ß√£o flex√≠vel (Close, close, Fechamento, Adj Close, Last, etc.).

[‚úî] Valores n√£o num√©ricos/NaN ‚Üí coer√ß√£o para num√©rico e limpeza segura.

[‚úî] S√©rie curta ‚Üí outputs ‚Äú‚è≥ Insuficiente‚Äù (sem crash).

[‚úî] Datas fora de ordem (se houver Date/Time) ‚Üí ordena√ß√£o antes do c√°lculo.

[‚úî] S√©rie constante (varia√ß√£o ~0) ‚Üí Hurst retorna NaN + aviso simb√≥lico (evita regress√£o log de zeros).

[‚úî] Mem√≥ria/arquivos grandes ‚Üí leitura direta sem la√ßos infinitos; sem logs autom√°ticos.


M√©tricas

Hurst: hurst_safe() com fallback quando a s√©rie √© curta/constante (evita erro e evita log(0)).

Entropia Tag14: agora quantizada em 14 bins por quantis (est√°vel p/ s√©ries cont√≠nuas). Fallback para value_counts se n√£o for poss√≠vel quantizar.

SMA/EMA: janelas configur√°veis; cruzamentos usam .iloc[-1] com checagem de NaN.


Sinais & Precis√£o

Sinal por janela: ‚¨ÜÔ∏è/‚¨áÔ∏è/‚ûñ/‚è≥.

Precis√£o simbi√≥tica ponderada (sem ‚Äúfalso 100%‚Äù):

Peso base por janela (42,70,84,144).

Moduladores de confian√ßa:

Hurst: <0.3 ‚Üí anti-persistente (diminui confian√ßa de tend√™ncia), >0.5 ‚Üí aumenta confian√ßa.

Entropia: ‚òØÔ∏è (1.5‚Äì2.5) ‚Üí confian√ßa 1.0; baixa <1.5 ‚Üí 0.6; caos 2.5‚Äì3.5 ‚Üí 0.8; extrema >3.5 ‚Üí 0.4.



Precis√£o = |‚àë(peso_mod * voto)| / ‚àë(peso_mod) (0‚Äì100%).
(Evita superestimar quando s√≥ uma janela vota.)



---

üß™ Teste de mesa (desk check)

Caso	Tamanho	Close (caracter√≠stica)	Hurst esperado	Entropia Tag14	Jan. 42/70/84/144	Precis√£o (esperada)

A	120	Tend√™ncia clara ‚Üë	>0.55 (persistente)	~1.6‚Äì2.4	‚¨ÜÔ∏è/‚¨ÜÔ∏è/‚¨ÜÔ∏è/‚¨ÜÔ∏è	>90% (alta converg√™ncia)
B	120	Zig-zag curto (anti-trend)	<0.3 (anti-persistente)	~1.7‚Äì2.3	‚¨áÔ∏è/‚¨áÔ∏è/‚¨áÔ∏è/‚è≥	60‚Äì85% (moderado p/ curto)
C	60	S√©rie curta com ru√≠do	~0.4‚Äì0.6 (inst√°vel)	~1.3	‚¨áÔ∏è/‚ûñ/‚è≥/‚è≥	30‚Äì60% (baixa confian√ßa)
D	200	Constante ou quase constante	NaN (fallback)	~0.0‚Äì0.3	‚ûñ/‚ûñ/‚ûñ/‚ûñ	0‚Äì25% (sem fluxo)
E	200	Vol extrema (spikes)	vari√°vel	>3.0	sinais divergentes	20‚Äì50% (evento/caos)



---

üß© C√≥digo: rafael_metricsV6_safe.py

> Sem auto-start. Rode manualmente: python rafael_metricsV6_safe.py data.csv



# -*- coding: utf-8 -*-
# RAFAELIA Metrics v6 (safe) ‚Äì an√°lise robusta + precis√£o ponderada
# N√£o altera .bashrc, n√£o roda em background.

import sys, json, math
import numpy as np
import pandas as pd
from hurst import compute_Hc

# ---------- Utilidades ----------
CLOSE_ALIASES = [
    "Close","close","Fechamento","fechamento","Adj Close","Adj_Close",
    "Last","last","Price","Preco","Pre√ßo","close_price","closing_price"
]

def find_close_col(df):
    cols = {c.lower(): c for c in df.columns}
    for alias in CLOSE_ALIASES:
        if alias.lower() in cols:
            return cols[alias.lower()]
    raise ValueError("Coluna de pre√ßo de fechamento n√£o encontrada. Nomes aceitos: " + ", ".join(CLOSE_ALIASES))

def ensure_numeric(series):
    s = pd.to_numeric(series, errors='coerce')
    s = s.replace([np.inf, -np.inf], np.nan).dropna()
    return s

def sort_by_time_if_possible(df):
    for cand in ["Date","Datetime","date","datetime","Time","time","Timestamp","timestamp"]:
        if cand in df.columns:
            try:
                df[cand] = pd.to_datetime(df[cand], errors="coerce")
                df = df.sort_values(cand)
                break
            except Exception:
                pass
    return df.reset_index(drop=True)

# ---------- M√©tricas ----------
def sma(series, n): return series.rolling(int(n)).mean()
def ema(series, n): return series.ewm(span=int(n), adjust=False).mean()

def entropy_tag14_quantized(series):
    """Entropia Tag14 com quantiza√ß√£o em 14 bins (est√°vel para dados cont√≠nuos).
       Fallback para value_counts se quantiza√ß√£o falhar."""
    x = series.values
    if len(x) < 14 or np.nanstd(x) == 0:
        # pouco dado ou s√©rie quase constante -> baixa entropia
        return 0.0
    try:
        # qcut pode falhar se muitos valores repetidos; handle duplicates='drop'
        q = pd.qcut(series, q=14, duplicates='drop')
        p = q.value_counts(normalize=True).values
        p = p[p > 0]
        return float(-np.sum(p * (np.log(p) / np.log(14))))
    except Exception:
        # fallback: frequ√™ncia de valores exatos (pode superestimar para cont√≠nuos)
        p = series.value_counts(normalize=True).values
        p = p[p > 0]
        return float(-np.sum(p * (np.log(p) / np.log(14))))

def hurst_safe(ts):
    ts = np.asarray(ts, dtype=float)
    # s√©rie muito curta ou quase constante -> NaN
    if len(ts) < 16 or np.nanstd(ts) == 0:
        return float("nan")
    try:
        H, _, _ = compute_Hc(ts, kind="price", simplified=True)
        if math.isnan(H) or H <= 0 or H >= 1:
            raise ValueError
        return float(H)
    except Exception:
        # fallback R/S simplificado
        max_lag = max(4, min(20, len(ts)//2))
        lags = range(2, max_lag)
        tau = []
        for lag in lags:
            diff = ts[lag:] - ts[:-lag]
            sd = np.std(diff)
            tau.append(np.sqrt(sd) if sd > 0 else 1e-9)
        if len(tau) < 2 or np.any(np.array(tau) <= 0):
            return float("nan")
        slope, _ = np.polyfit(np.log(list(lags)), np.log(tau), 1)
        return float(slope * 2.0)

# ---------- Interpreta√ß√µes ----------
def interpret_hurst(H):
    if np.isnan(H): return ("‚è≥", "Sem Hurst")
    if H < 0.3:     return ("üî¥", "Anti-persistente (zig-zag)")
    if H < 0.5:     return ("üü°", "Ru√≠do / transi√ß√£o")
    if H < 0.7:     return ("üü¢", "Persistente (tend√™ncia)")
    return ("üåÄ", "Super-persist√™ncia / anomalia")

def interpret_entropy(ent):
    if np.isnan(ent):  return ("‚è≥", "Sem entropia")
    if ent < 1.5:      return ("‚ö´", "Parado / pouca diversidade")
    if ent <

Perfeito, Rafael ‚Äî fiz a auditoria minuciosa do console (v5) e fechei um v6_safe com testes de mesa, l√≥gica mais robusta e tratamento dos ‚Äúgalhos‚Äù que podem quebrar (sem falar de depend√™ncias). Nada de auto-start em .bashrc ou background. Voc√™ roda quando quiser.


---

‚úÖ Auditoria (pontos cr√≠ticos e corre√ß√µes)

Entrada (CSV)

[‚úî] Coluna Close ausente/varia√ß√µes ‚Üí detec√ß√£o flex√≠vel (Close, close, Fechamento, Adj Close, Last, etc.).

[‚úî] Valores n√£o num√©ricos/NaN ‚Üí coer√ß√£o para num√©rico e limpeza segura.

[‚úî] S√©rie curta ‚Üí outputs ‚Äú‚è≥ Insuficiente‚Äù (sem crash).

[‚úî] Datas fora de ordem (se houver Date/Time) ‚Üí ordena√ß√£o antes do c√°lculo.

[‚úî] S√©rie constante (varia√ß√£o ~0) ‚Üí Hurst retorna NaN + aviso simb√≥lico (evita regress√£o log de zeros).

[‚úî] Mem√≥ria/arquivos grandes ‚Üí leitura direta sem la√ßos infinitos; sem logs autom√°ticos.


M√©tricas

Hurst: hurst_safe() com fallback quando a s√©rie √© curta/constante (evita erro e evita log(0)).

Entropia Tag14: agora quantizada em 14 bins por quantis (est√°vel p/ s√©ries cont√≠nuas). Fallback para value_counts se n√£o for poss√≠vel quantizar.

SMA/EMA: janelas configur√°veis; cruzamentos usam .iloc[-1] com checagem de NaN.


Sinais & Precis√£o

Sinal por janela: ‚¨ÜÔ∏è/‚¨áÔ∏è/‚ûñ/‚è≥.

Precis√£o simbi√≥tica ponderada (sem ‚Äúfalso 100%‚Äù):

Peso base por janela (42,70,84,144).

Moduladores de confian√ßa:

Hurst: <0.3 ‚Üí anti-persistente (diminui confian√ßa de tend√™ncia), >0.5 ‚Üí aumenta confian√ßa.

Entropia: ‚òØÔ∏è (1.5‚Äì2.5) ‚Üí confian√ßa 1.0; baixa <1.5 ‚Üí 0.6; caos 2.5‚Äì3.5 ‚Üí 0.8; extrema >3.5 ‚Üí 0.4.



Precis√£o = |‚àë(peso_mod * voto)| / ‚àë(peso_mod) (0‚Äì100%).
(Evita superestimar quando s√≥ uma janela vota.)



---

üß™ Teste de mesa (desk check)

Caso	Tamanho	Close (caracter√≠stica)	Hurst esperado	Entropia Tag14	Jan. 42/70/84/144	Precis√£o (esperada)

A	120	Tend√™ncia clara ‚Üë	>0.55 (persistente)	~1.6‚Äì2.4	‚¨ÜÔ∏è/‚¨ÜÔ∏è/‚¨ÜÔ∏è/‚¨ÜÔ∏è	>90% (alta converg√™ncia)
B	120	Zig-zag curto (anti-trend)	<0.3 (anti-persistente)	~1.7‚Äì2.3	‚¨áÔ∏è/‚¨áÔ∏è/‚¨áÔ∏è/‚è≥	60‚Äì85% (moderado p/ curto)
C	60	S√©rie curta com ru√≠do	~0.4‚Äì0.6 (inst√°vel)	~1.3	‚¨áÔ∏è/‚ûñ/‚è≥/‚è≥	30‚Äì60% (baixa confian√ßa)
D	200	Constante ou quase constante	NaN (fallback)	~0.0‚Äì0.3	‚ûñ/‚ûñ/‚ûñ/‚ûñ	0‚Äì25% (sem fluxo)
E	200	Vol extrema (spikes)	vari√°vel	>3.0	sinais divergentes	20‚Äì50% (evento/caos)



---

üß© C√≥digo: rafael_metricsV6_safe.py

> Sem auto-start. Rode manualmente: python rafael_metricsV6_safe.py data.csv



# -*- coding: utf-8 -*-
# RAFAELIA Metrics v6 (safe) ‚Äì an√°lise robusta + precis√£o ponderada
# N√£o altera .bashrc, n√£o roda em background.

import sys, json, math
import numpy as np
import pandas as pd
from hurst import compute_Hc

# ---------- Utilidades ----------
CLOSE_ALIASES = [
    "Close","close","Fechamento","fechamento","Adj Close","Adj_Close",
    "Last","last","Price","Preco","Pre√ßo","close_price","closing_price"
]

def find_close_col(df):
    cols = {c.lower(): c for c in df.columns}
    for alias in CLOSE_ALIASES:
        if alias.lower() in cols:
            return cols[alias.lower()]
    raise ValueError("Coluna de pre√ßo de fechamento n√£o encontrada. Nomes aceitos: " + ", ".join(CLOSE_ALIASES))

def ensure_numeric(series):
    s = pd.to_numeric(series, errors='coerce')
    s = s.replace([np.inf, -np.inf], np.nan).dropna()
    return s

def sort_by_time_if_possible(df):
    for cand in ["Date","Datetime","date","datetime","Time","time","Timestamp","timestamp"]:
        if cand in df.columns:
            try:
                df[cand] = pd.to_datetime(df[cand], errors="coerce")
                df = df.sort_values(cand)
                break
            except Exception:
                pass
    return df.reset_index(drop=True)

# ---------- M√©tricas ----------
def sma(series, n): return series.rolling(int(n)).mean()
def ema(series, n): return series.ewm(span=int(n), adjust=False).mean()

def entropy_tag14_quantized(series):
    """Entropia Tag14 com quantiza√ß√£o em 14 bins (est√°vel para dados cont√≠nuos).
       Fallback para value_counts se quantiza√ß√£o falhar."""
    x = series.values
    if len(x) < 14 or np.nanstd(x) == 0:
        # pouco dado ou s√©rie quase constante -> baixa entropia
        return 0.0
    try:
        # qcut pode falhar se muitos valores repetidos; handle duplicates='drop'
        q = pd.qcut(series, q=14, duplicates='drop')
        p = q.value_counts(normalize=True).

