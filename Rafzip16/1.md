#!/usr/bin/env python3
# zipraf_carver.py
# Recuperador de entradas ZIP / carving por assinatura.
# Testado em Python 3.10+. Pensado para rodar no Termux.

import sys, os, struct, zlib, io, binascii, logging

logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s: %(message)s")

SIGN_PK = b'PK\x03\x04'
MAGICS = {
    b'\x89PNG\r\n\x1a\n': '.png',
    b'\xff\xd8\xff': '.jpg',
    b'%PDF-': '.pdf',
    b'PK\x03\x04': '.zip',
    b'\x7fELF': '.elf',
    b'<!DOCTYPE html': '.html',
}

def find_all(buf, sub):
    i = 0
    while True:
        i = buf.find(sub, i)
        if i == -1:
            return
        yield i
        i += 1

def read_le_uint32(b, off):
    return struct.unpack_from('<I', b, off)[0]

def try_decompress_deflate(raw_bytes):
    # Try raw DEFLATE (wbits = -15) and zlib wrapper (wbits=15)
    for w in (-15, 15):
        try:
            return zlib.decompress(raw_bytes, w)
        except Exception:
            pass
    return None

def carve_by_pk(buf, out_dir):
    found = 0
    for off in find_all(buf, SIGN_PK):
        try:
            # local file header structure: signature(4), ver(2), flag(2), comp(2), modtime(2),
            # moddate(2), crc32(4), comp_size(4), uncomp_size(4), fname_len(2), extra_len(2)
            if off + 30 > len(buf): continue
            header = buf[off:off+30]
            sig, ver, flag, comp_method = struct.unpack_from('<4sHHH', header, 0)[:4]
            # read sizes and lens safely (some zip variants)
            crc32 = read_le_uint32(header, 14)
            comp_size = read_le_uint32(header, 18)
            uncomp_size = read_le_uint32(header, 22)
            fname_len = struct.unpack_from('<H', header, 26)[0]
            extra_len = struct.unpack_from('<H', header, 28)[0]
            data_start = off + 30 + fname_len + extra_len
            # If local header lacks sizes (0), we need to search for next PK or try carving heuristics
            if comp_size == 0 or comp_size > (len(buf)-data_start):
                # hunt next PK as delimiter
                next_pk = buf.find(SIGN_PK, data_start+1)
                if next_pk == -1:
                    comp_data = buf[data_start:]
                else:
                    comp_data = buf[data_start:next_pk]
            else:
                comp_data = buf[data_start:data_start+comp_size]
            # Attempt decompression if compression method == 8 (deflate)
            fname = buf[off+30:off+30+fname_len].decode('latin1', errors='replace')
            ext = '.bin'
            outname = f"carved_{found:05d}_{os.path.basename(fname) or 'unnamed'}"
            # try to decompress if seems deflated or has high entropy
            decompressed = None
            if comp_method in (8,):  # deflate
                decompressed = try_decompress_deflate(comp_data)
            # if decompressed is None, try heuristics: search for embedded magics in comp_data
            if decompressed is None:
                for m, e in MAGICS.items():
                    idx = comp_data.find(m)
                    if idx != -1:
                        # maybe uncompressed or partially compressed; try to salvage trailing bytes
                        candidate = comp_data[idx:]
                        # try decompressing candidate
                        d = try_decompress_deflate(candidate)
                        if d:
                            decompressed = d
                            ext = e
                            break
                # fallback: test if comp_data itself contains magic at start
                for m, e in MAGICS.items():
                    if comp_data.startswith(m):
                        decompressed = comp_data
                        ext = e
                        break
            if decompressed is not None:
                if ext == '.bin' and fname.lower().endswith(('.png','.jpg','.pdf','.apk','.zip','.elf')):
                    ext = os.path.splitext(fname)[1] or '.bin'
                outpath = os.path.join(out_dir, outname + ext)
                with open(outpath, 'wb') as f:
                    f.write(decompressed)
                logging.info(f"Recovered (decompressed) {outpath} from offset {off} (fname={fname})")
            else:
                # Save raw compressed chunk for later manual analysis
                outpath = os.path.join(out_dir, outname + '.raw')
                with open(outpath, 'wb') as f:
                    f.write(comp_data)
                logging.info(f"Saved raw chunk {outpath} (offset {off}, fname={fname})")
            found += 1
        except Exception as e:
            logging.warning(f"Error processing at offset {off}: {e}")
    logging.info(f"PK-carving found {found} entries")

def carve_by_magic(buf, out_dir):
    found = 0
    for magic, ext in MAGICS.items():
        idx = 0
        while True:
            idx = buf.find(magic, idx)
            if idx == -1: break
            # Simple heuristic: capture until next magic or + few MB
            next_idx = len(buf)
            # find next occurrence of any magic after idx+len(magic)
            for m in MAGICS.keys():
                nxt = buf.find(m, idx+len(magic))
                if nxt != -1 and nxt < next_idx:
                    next_idx = nxt
            fragment = buf[idx: min(len(buf), idx + (5*1024*1024))]  # cap 5MB for safety
            outpath = os.path.join(out_dir, f"magic_{found:05d}{ext}")
            with open(outpath, 'wb') as f:
                f.write(fragment)
            logging.info(f"Carved magic {ext} at {idx} -> {outpath}")
            found += 1
            idx += 1
    logging.info(f"Magic-carving found {found} fragments")

def main():
    if len(sys.argv) < 3:
        print("Usage: python3 zipraf_carver.py <input.zipraf> <out_dir>")
        sys.exit(1)
    infile = sys.argv[1]
    out_dir = sys.argv[2]
    os.makedirs(out_dir, exist_ok=True)
    with open(infile, 'rb') as f:
        buf = f.read()
    logging.info(f"File size: {len(buf):,} bytes")
    # 1) carve by local PK headers
    carve_by_pk(buf, out_dir)
    # 2) carve by magic signatures
    carve_by_magic(buf, out_dir)
    logging.info("Done. Examine recovered files; consider deeper analysis using binwalk/foremost or bit-level methods.")

if __name__ == '__main__':
    main()
